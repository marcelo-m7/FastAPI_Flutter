# Relatório Técnico – Projeto *Boteco\_PRO*

## 1. Introdução

O presente relatório descreve o desenvolvimento de uma base de dados relacional para a gestão de um pequeno restaurante/bar, denominada *Boteco\_PRO*. O principal objetivo é suportar as operações do restaurante – desde a definição do menu (pratos e bebidas e seus ingredientes), gestão de stock de produtos, registo de pedidos e faturação aos clientes, até à gestão de funcionários e eventos especiais – assegurando integridade dos dados e automatização de tarefas rotineiras. A solução foi implementada em SQL Server (Transact-SQL), seguindo os requisitos do enunciado da unidade curricular Base de Dados II. Foram utilizadas diversas funcionalidades do SQL Server, incluindo **views** para consultas frequentes, **views materializadas** (através de tabelas de apoio) para melhoria de desempenho, **stored procedures** para encapsular lógica de negócios (operações de inserção e processamento de pedidos), **functions** para cálculos reutilizáveis e **triggers** para automatizar atualizações do sistema (e.g. abatimento de stock).

A seguir, detalhamos o esquema relacional da base de dados, as principais consultas realizadas, as views criadas (normais e materializadas), as stored procedures desenvolvidas, as functions implementadas (scalar e table-valued), os triggers de automatização, e por fim uma conclusão sobre como a solução atende aos objetivos propostos.

## 2. Esquema Relacional

O esquema relacional do *Boteco\_PRO* foi projetado em conformidade com a 3ª Forma Normal, contemplando todas as entidades necessárias à gestão do restaurante. A figura abaixo apresenta o modelo Entidade-Relacionamento do sistema, mostrando as tabelas e relações (chaves primárias e estrangeiras) entre elas.

&#x20;*Figura 1: Diagrama Entidade-Relacionamento do *Boteco\_PRO*, mostrando as tabelas do esquema e seus relacionamentos principais (PK/FK).*

As tabelas podem ser agrupadas por domínio funcional conforme descrito a seguir:

* **Menu e Produtos:** Inclui as tabelas **Categoria**, **Produto**, **Fornecedor**, **Prato**, **Bebida** e as tabelas de relação **Prato\_Produto** e **Bebida\_Produto**. A tabela **Categoria** guarda as categorias de pratos (e.g. Carne, Peixe, Massas), com `id_categoria` como chave primária. **Fornecedor** armazena os fornecedores de produtos, com chave primária `id_fornecedor`. A tabela **Produto** representa os produtos ou ingredientes em stock, contendo campos como nome, descrição, preço de custo e controle de stock (`stock_atual`, `stock_minimo`, etc.), tendo `id_produto` como chave primária. Cada **Produto** referencia um **Fornecedor** através da chave estrangeira `id_fornecedor`. Abaixo vemos um trecho da definição da tabela *Produto* no script SQL, incluindo a constraint de chave estrangeira para *Fornecedor*:

```sql
CREATE TABLE Produto (
    id_produto INT IDENTITY(1,1) PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    -- ... outros campos ...
    id_fornecedor INT,
    FOREIGN KEY (id_fornecedor) REFERENCES Fornecedor(id_fornecedor)
);
```

**Prato** e **Bebida** representam, respectivamente, os pratos do menu (refeições) e as bebidas servidas. Ambos possuem chaves primárias auto-incrementais (`id_prato`, `id_bebida`) e incluem campos como nome, preço de venda e tempo de preparo. Tanto *Prato* quanto *Bebida* possuem uma chave estrangeira `id_categoria` que indica a qual categoria aquele item pertence (por exemplo, um prato pode ser de categoria “Carne” ou “Peixe”). As composições dos pratos e bebidas em termos de ingredientes são modeladas pelas tabelas de interseção **Prato\_Produto** e **Bebida\_Produto**. A tabela **Prato\_Produto** relaciona quais produtos (ingredientes) compõem cada prato, incluindo a quantidade de cada ingrediente utilizada no prato. Ela utiliza uma chave primária composta por (`id_prato`, `id_produto`) e cada um destes também é chave estrangeira referenciando respectivamente *Prato* e *Produto*. De forma análoga, **Bebida\_Produto** relaciona bebidas a produtos (por exemplo, ingredientes de um cocktail), com chave primária composta (`id_bebida`, `id_produto`) e foreign keys para *Bebida* e *Produto*. Esse modelo relacional garante integridade referencial – por exemplo, não é possível associar um produto a um prato ou bebida inexistente, nem eliminar um fornecedor que esteja referenciado por algum produto, devido às **FK** definidas.

* **Funcionários e Carreiras:** Para gerir os recursos humanos, o esquema inclui **Carreira**, **Nivel\_Carreira**, **Funcionario**, **Funcionario\_Login** e **Horas\_Trabalhadas**. A tabela **Carreira** define os tipos de carreira/cargo (por exemplo: Cozinheiro, Empregado de Mesa, etc.) e **Nivel\_Carreira** define níveis dentro de cada carreira (por exemplo: Cozinheiro de 1ª Classe, 2ª Classe, Chef). Ambas possuem chaves primárias próprias (`id_carreira`, `id_nivel_carreira`). A tabela **Funcionario** armazena os dados dos funcionários (nome, data de admissão, valor hora, etc.), usando `id_funcionario` como chave primária. Cada funcionário possui uma carreira e um nível associados, armazenados como chaves estrangeiras `id_carreira` e `id_nivel_carreira` que referenciam as tabelas correspondentes. Adicionalmente, **Funcionario** inclui um campo `senha_hash` (hash da senha) para fins de autenticação. A tabela **Funcionario\_Login** guarda informações de login de funcionários (usuário e senha hash), tendo `id_funcionario` como chave primária e simultaneamente chave estrangeira para *Funcionario*, garantindo correspondência 1-para-1. A tabela **Horas\_Trabalhadas** registra o total de horas trabalhadas por funcionário em cada mês/ano (horas normais e horas extra). Sua chave primária composta é `(id_funcionario, mes, ano)`, assegurando que cada funcionário tenha no máximo um registro por mês. A foreign key `id_funcionario` referencia *Funcionario*, de modo que o registo de horas depende de um funcionário válido. Esses relacionamentos permitem calcular vencimentos mensais e controlar a folha de ponto dos funcionários.

* **Clientes, Mesas, Pedidos e Faturas:** O atendimento aos clientes é modelado pelas tabelas **Cliente**, **Mesa**, **Pedido**, **Pedido\_Prato**, **Pedido\_Bebida** e **Fatura**. A tabela **Cliente** guarda os dados dos clientes (nome, NIF/contribuinte, endereço, etc.) com chave primária `id_cliente`. **Mesa** representa as mesas do restaurante, com `id_mesa` como PK e atributos como número da mesa, quantidade de lugares e um indicativo se está disponível. A tabela **Pedido** registra os pedidos realizados – cada pedido está associado a um cliente (pode ser um cliente regular ou “ocasional”) e a uma mesa, além de indicar o funcionário que atendeu. Assim, *Pedido* possui as foreign keys `id_mesa`, `id_funcionario` e `id_cliente` que referenciam *Mesa*, *Funcionario* e *Cliente*, respectivamente. Também armazena a data/hora do pedido, um status (por exemplo “Em preparo”, “Concluído”) e observações. As items de cada pedido são armazenados em **Pedido\_Prato** e **Pedido\_Bebida**, que detalham quais pratos e quais bebidas foram solicitados em determinado pedido. Cada *Pedido\_Prato* registra um prato de um pedido (com a quantidade pedida), e tem PK composta (`id_pedido`, `id_prato`) e FKs para *Pedido* e *Prato*. Analogamente, **Pedido\_Bebida** relaciona pedidos com bebidas, com PK composta (`id_pedido`, `id_bebida`) e FKs para *Pedido* e *Bebida*. A tabela **Fatura** representa a fatura gerada ao finalizar um pedido/mesa. Contém `id_fatura` como chave primária, e campos como data de emissão, valor total, valor de IVA, etc. Importante, *Fatura* referencia o *Pedido* correspondente através de `id_pedido` (FK). Dessa forma, cada pedido finalizado tem exatamente uma fatura associada, contendo o resumo financeiro do consumo daquele pedido. Os campos `tipo_iva_comida` e `tipo_iva_bebida` guardam as taxas de IVA aplicadas (p.ex. 13% para comida e 23% para bebidas), conforme requerido no enunciado.

* **Eventos Especiais e Menus Promocionais:** O restaurante pode criar eventos especiais (como Dia dos Namorados, Natal, etc.) com menus específicos. Isso é modelado pelas tabelas **Evento\_Especial**, **Menu\_Especial** e **Menu\_Especial\_Prato**. **Evento\_Especial** define os eventos (chave primária `id_evento`, nome, descrição, data de início e fim). **Menu\_Especial** representa um menu promocional oferecido em certo evento, possuindo `id_menu` como PK, um nome/descritivo, preço fixo e uma FK `id_evento` referenciando o *Evento\_Especial* ao qual pertence. A relação entre *Menu\_Especial* e os pratos incluídos nesse menu é dada por **Menu\_Especial\_Prato**, que indica quais pratos fazem parte de cada menu especial. Essa tabela possui chave primária composta (`id_menu`, `id_prato`) e FKs referenciando *Menu\_Especial* e *Prato*. Assim, garante-se integridade (não há pratos em menus inexistentes, e ao apagar um menu especial suas associações são removidas em cascata devido às FKs).

Em resumo, o esquema relacional contém todas as entidades necessárias: entidades principais (**Produto**, **Prato**, **Bebida**, **Pedido**, etc.), entidades de referência (**Categoria**, **Fornecedor**, **Cliente**, **Carreira**, **Evento\_Especial**, etc.) e tabelas associativas para modelar relações muitos-para-muitos (**Prato\_Produto**, **Pedido\_Prato**, etc.). As **chaves primárias** foram definidas seguindo a regra de singularidade de cada registro (muitas usando campos do tipo IDENTITY para geração automática de IDs únicos). As **chaves estrangeiras** asseguram referencialidade entre tabelas – conforme exemplificado no código da tabela *Produto* acima e outras definições similares – evitando dados órfãos e mantendo a consistência entre, por exemplo, pedidos e itens, produtos e fornecedores, etc. Todo o esquema foi implementado via script SQL (*01\_Criação\_DB.sql*), conforme demonstrado nos trechos de código citados.

## 3. Queries efetuadas

Diversas consultas SQL foram desenvolvidas para extrair informações chave da base de dados e responder às necessidades do negócio. Entre as principais **queries** realizadas estão consultas analíticas solicitadas no enunciado, tais como:

* **Valor gasto em stocks por período de tempo:** cálculo do custo total dos produtos (ingredientes) utilizados num intervalo de datas definido (data de início e fim). Esta query permite ao gestor saber quanto em euros de ingredientes foram consumidos num dado período. Foi implementada considerando os itens de pedidos consumidos e o preço de custo de cada produto.
* **Valor gasto em vencimentos por período (mensal/anual):** soma dos salários pagos aos funcionários num determinado mês e ano. Para esta consulta, são agregadas as horas trabalhadas de cada funcionário (horas normais e extra) multiplicadas pelo respetivo valor hora e fatores de extra, para se obter o total de vencimentos num mês/ano.
* **Valor recebido em refeições por período:** total de vendas (receita) obtida num certo intervalo de datas, calculado a partir das faturas emitidas (somatório do valor total das faturas dentro do período).
* **Resumo financeiro por período:** consolidação dos três indicadores anteriores – gastos em stock, gastos em vencimentos e receita obtida – num mesmo resultado, para um período especificado, permitindo avaliar o balanço (por exemplo, lucro/prejuízo operacional no período).

As quatro consultas mencionadas acima foram implementadas e otimizadas sob a forma de **views** no sistema (ver Seção 4 a seguir), nomeadamente `vw_ValorGastoStocksPorPeriodo`, `vw_ValorGastoVencimentosPorPeriodo`, `vw_ValorRecebidoPorPeriodo` e `vw_ResumoFinanceiroPorPeriodo`. A decisão de usar views para estas queries deve-se à conveniência de reutilização e à facilidade de obter os resultados atualizados simplesmente consultando a view, além de permitir esconder a complexidade das junções e agregações por detrás de um nome lógico.

Além dessas, foram desenvolvidas outras queries para apoiar a gestão diária e funcionalidades extras do sistema, por exemplo: consulta de **estoque atual** de produtos (listando todos os produtos com quantidade em stock, comparando com estoque mínimo), consulta de **produtos abaixo do estoque mínimo** (que serviu para identificar necessidades de reposição), listagem de **funcionários e suas carreiras/níveis**, e listagem de **menus especiais ativos com seus pratos**. Estas consultas adicionais também foram implementadas via *views* para conveniência – por exemplo, a view `vw_EstoqueAtual` mostra todos os produtos com seus níveis de stock e mínimos, enquanto `vw_ProdutosAbaixoMinimo` retorna especificamente os produtos cujo stock atual está abaixo do mínimo definido. Do mesmo modo, `vw_ListaFuncionarios` exibe uma lista completa de funcionários incluindo informações da carreira e nível associados, e `vw_MenusEspeciaisAtivos` mostra os menus promocionais vigentes e os pratos associados a cada um. Essas queries suplementares demonstram preocupação com a **inovação e completude** da solução, indo além do requisitado estritamente, de forma a tornar o sistema mais útil e pronto para uso em cenários reais (por exemplo, facilitando ao gestor identificar rapidamente se há produtos em falta ou verificar quais menus especiais estão em vigor).

Cada consulta SQL desenvolvida foi testada através de scripts de teste (incluídos na pasta *use\_cases* do projeto, e.g. `Teste_Pedidos.sql`, `Teste_Especiais.sql`, etc.), garantindo que os resultados obtidos correspondem ao esperado. Por exemplo, após inserir dados de exemplo, foi possível executar consultas como *“Qual o valor total gasto em ingredientes no mês de Maio?”* ou *“Quantos pratos foram vendidos na semana passada e qual a receita?”*, obtendo-se respostas imediatas via as views configuradas. Em suma, as **queries efetuadas** cobrem tanto requisitos funcionais (relatórios financeiros por período) quanto operações de apoio à gestão (listas de stock, funcionários, etc.), constituindo a base para construção de relatórios gerenciais e tomadas de decisão informadas.

## 4. Views criadas

Conforme mencionado, várias **views** SQL foram criadas para representar consultas complexas de forma fácil de reutilizar. Podemos dividi-las entre *views normais* (consultas lógicas não materializadas) e a *view materializada* solicitada.

**Views analíticas principais:** Foram implementadas quatro views correspondentes às consultas analíticas requeridas pelo projeto, que permitem obter indicadores financeiros por período:

* `vw_ValorGastoStocksPorPeriodo` – View que calcula o **valor gasto em stocks de produtos** (custo de ingredientes utilizados) entre duas datas (início e fim do período). Internamente, esta view resume as quantidades de cada produto utilizadas em pedidos dentro do período e multiplica pelo preço de custo de cada produto, somando o total. Assim, retorna um valor total em euros gasto em matérias-primas no período definido.
* `vw_ValorGastoVencimentosPorPeriodo` – View para **valor gasto em vencimentos de funcionários** num determinado período. Como os vencimentos foram considerados numa base mensal, esta view agrega, para cada mês/ano especificado, o custo total com salários. Leva em conta as horas trabalhadas (normais e extra) registradas em `Horas_Trabalhadas` e o valor hora de cada funcionário, aplicando as regras de pagamento de horas extra (por exemplo, 1.5x ou 2x do valor hora normal conforme a quantidade de horas extra, conforme descrito no enunciado). O resultado é o total pago em salários no mês/ano em questão.
* `vw_ValorRecebidoPorPeriodo` – View que calcula o **valor recebido em refeições (faturação)** num intervalo de tempo. Basicamente soma o campo `valor_total` das *Faturas* emitidas entre a data de início e fim fornecidas. É, portanto, a receita bruta obtida das vendas nesse período.
* `vw_ResumoFinanceiroPorPeriodo` – View de **resumo financeiro** que combina os três indicadores anteriores. Para um dado período, esta view apresenta, em uma única estrutura, os valores gastos em stocks, gastos em vencimentos e valor recebido (receita), possibilitando ver numa só consulta os principais números do período. Dependendo da implementação, esta view ou retorna colunas separadas (por exemplo, `total_stock`, `total_vencimentos`, `total_receita` para o período) ou retorna múltiplas linhas categorizadas. No nosso caso, optámos por retornar colunas distintas, facilitando cálculos como receita menos despesas. Internamente, a view obtém os valores juntando subconsultas ou através das próprias views anteriores (aninhadas) – por exemplo, selecionando de `vw_ValorGastoStocksPorPeriodo` e `vw_ValorGastoVencimentosPorPeriodo` e juntando com `vw_ValorRecebidoPorPeriodo` por período, de modo a compor a visão completa.

Todas essas views não materializadas são atualizadas em tempo real – ou seja, ao consultar, o SQL Server executa a query subjacente nos dados atuais. Isso garante que decisões do gestor sejam tomadas com base em dados atualizados. As definições das views encontram-se no script *02\_Base\_Views.sql*.

**Views de apoio adicionais:** Além das principais, foram criadas outras views para facilitar operações de monitorização e gestão, evidenciando o esforço em criar uma base de dados mais funcional. Dentre elas:

* `vw_EstoqueAtual` – lista todos os produtos em stock mostrando quantidade atual em comparação com o mínimo. Essa view foi útil para rapidamente verificar o nível de estoque e identificar produtos potencialmente em falta.
* `vw_ProdutosAbaixoMinimo` – mostra somente os produtos cujo `stock_atual` está abaixo do `stock_minimo`. Com essa visão, o gestor pode listar apenas os itens que precisam de reposição imediata. A combinação dessa view com os triggers de reposição automática (ver secção 7) permitiu implementar uma funcionalidade de reabastecimento automático do stock, mas a view ainda serve para relatório/manual conferência.
* `vw_ListaFuncionarios` – retorna uma lista de todos os funcionários com informações relevantes, incluindo os campos relacionados (por exemplo, descrição da carreira e nível, que são obtidos via junção com as tabelas *Carreira* e *Nivel\_Carreira*). Essa view facilita consultas de RH, como listar todos funcionários e seus cargos.
* `vw_MenusEspeciaisAtivos` – lista os menus especiais que estão ativos (dentro da data de vigência atual, comparando data atual com data\_inicio/data\_fim do evento) e os pratos associados a cada menu. Isso ajuda, por exemplo, o garçom ou gestor a verificar quais promoções estão disponíveis no dia e o que elas incluem.

Essas views de apoio encontram-se nos ficheiros correspondentes dentro de *backend/docs* e *backend/src/db/use\_cases* (por exemplo, *VWs\_Estoque.sql*, *VW\_Funcionários.sql*, *VW\_Especiais.sql*). Elas seguem uma sintaxe similar: cada uma é criada com um `CREATE VIEW ... AS SELECT ...` juntando as tabelas necessárias e filtrando condições adequadas (e.g. estoque abaixo do mínimo, eventos ativos). Assim, enriquecem a base de dados com **visões lógicas** úteis ao utilizador final, sem necessidade de escrever consultas complexas manualmente.

**View Materializada – Stocks Utilizados:** O enunciado exigia a criação de uma *materialized view* (view materializada) para listagem de stocks de produtos utilizados por período de tempo, com um índice para pesquisa rápida por nome do produto. No SQL Server, não existe diretamente o objeto *materialized view* (como em outros SGBDs); em vez disso, costuma-se usar *Indexed Views* ou implementar manualmente via tabelas e triggers. Optámos por uma implementação manual, criando uma tabela de apoio que armazena a materialização dos dados de consumo de produtos:

* Foi criada a tabela **mv\_StocksUtilizadosPorPeriodo** com colunas `id_produto`, `nome_produto`, `data` e `quantidade_utilizada`. Esta tabela funciona como a view materializada, armazenando explicitamente, para cada produto e data (dia), a quantidade total daquele produto utilizada em pedidos nessa data.
* Em seguida, para alimentar esta tabela, foram definidos **triggers** que inserem registros conforme novos pedidos são feitos (detalhes na seção 7). Ou seja, sempre que ingredientes são abatidos do stock por causa de um pedido, o trigger correspondente registra na *mv\_StocksUtilizadosPorPeriodo* a quantidade utilizada de cada produto naquela data (permitindo agregar por dia).
* Adicionalmente, foi criado um **índice** sobre a coluna `nome_produto` desta tabela materializada, conforme solicitado, a fim de agilizar pesquisas pelo nome do produto. Este índice torna rápida a consulta “listar os consumos de um certo produto pelo nome” na tabela materializada, cumprindo a função de uma indexed view.

Em resumo, a *materialized view* requerida foi implementada via a tabela `mv_StocksUtilizadosPorPeriodo` e mantida atualizada pelos triggers *trg\_AtualizarMV\_Stocks* (ver seção de triggers). A presença do índice `idx_nome_produto` sobre essa tabela garante desempenho otimizado em buscas por produto. Essa solução satisfaz o requisito de materialização, armazenando de forma redundante os dados de consumo para acesso mais rápido, ao custo de maior complexidade de manutenção (o que foi resolvido com os automatismos).

Em conclusão desta seção, as **views criadas** (8 views no total, sendo 7 normais e 1 materializada simulada) oferecem uma camada de acesso aos dados de alto nível, facilitando imenso a obtenção de informações estratégicas. As views principais por período cumprem exatamente o pretendido no projeto prático, enquanto as views adicionais e a materializada demonstram preocupação extra em tornar o sistema eficiente e completo.

## 5. Stored Procedures desenvolvidas

Foram implementadas diversas **stored procedures (SP)** para encapsular operações de manipulação e consulta de dados, visando tanto cumprir requisitos funcionais quanto oferecer comodidade e segurança na interação com a base de dados. Abaixo apresentamos a listagem de todas as stored procedures desenvolvidas, agrupando-as por categoria de funcionalidade, com uma breve explicação e objetivo de cada uma:

**a) Procedures de Inserção de Dados Básicos:** permitem inserir novos registros nas tabelas principais de cadastro do sistema, abstraindo a lógica de inserção e facilitando a reutilização:

* **`sp_InserirCategoria`** – Insere uma nova categoria de prato na tabela *Categoria*, recebendo como parâmetro o nome da categoria. Evita categorias duplicadas (poderia incluir lógica de verificação, se implementado) e retorna/indica sucesso da operação.
* **`sp_InserirFornecedor`** – Regista um novo fornecedor na tabela *Fornecedor*, com nome e contactos (email, telefone) fornecidos. Garante a criação adequada de um fornecedor que poderá ser referenciado por produtos.
* **`sp_InserirProduto`** – Adiciona um novo produto (ingrediente) ao stock na tabela *Produto*. Recebe detalhes como nome, descrição, preço de custo, estoque inicial, estoque mínimo e quantidade padrão de encomenda, bem como o fornecedor associado (id do fornecedor). Insere o produto e inicializa seus valores de stock. Esta SP facilita o cadastro de novos ingredientes no sistema.
* **`sp_InserirPrato`** – Insere um novo prato no menu (tabela *Prato*). São informados nome do prato, preço de venda, tempo de preparo estimado e categoria a que pertence (`id_categoria`). Regista o prato e retorna seu ID, para posteriormente associar ingredientes.
* **`sp_InserirBebida`** – De forma análoga ao *prato*, insere uma nova bebida no menu (tabela *Bebida*), com nome, preço, tempo de preparo e categoria (por ex., bebidas podem também ser categorizadas, se aplicável – no nosso esquema usamos categorias principalmente para pratos, mas mantivemos campo de categoria em *Bebida* também).
* **`sp_AssociarIngredientesAoPrato`** – Esta procedure auxilia na construção da receita de um prato. Recebe o `id_prato` e uma lista de ingredientes (produtos) com as respectivas quantidades necessárias no preparo daquele prato, inserindo esses registros na tabela *Prato\_Produto*. Internamente, para cada ingrediente fornecido, executa um INSERT em *Prato\_Produto* associando o produto ao prato com a quantidade (`quantidade_utilizada`). Assim, automatiza o processo de definir quais produtos compõem um novo prato do menu. *(Nota: Caso um prato tenha muitos ingredientes, esta SP evita múltiplas instruções manuais de INSERT.)*

**b) Procedures de Gestão de Funcionários:** englobam a criação de carreiras, níveis, funcionários e registro de horas:

* **`sp_InserirCarreira`** – Insere um novo tipo de carreira na tabela *Carreira*, recebendo a descrição da carreira (ex.: *Cozinheiro*, *Gerente*, etc.). Serve para ampliar o conjunto de cargos disponíveis.
* **`sp_InserirNivelCarreira`** – Insere um novo nível dentro de uma carreira na tabela *Nivel\_Carreira*. Recebe a descrição do nível e possivelmente referência a qual carreira pertence (no nosso esquema *Nivel\_Carreira* não referencia diretamente *Carreira*, sendo uma lista geral de níveis). Poderia ser adaptado para relacionar a uma carreira específica se necessário.
* **`sp_InserirFuncionario`** – Regista um novo funcionário na tabela *Funcionario*. Parametriza nome, data de admissão, valor hora acordado, e as referências à carreira e nível correspondentes (ids). Insere o funcionário e retorna seu id. Essa SP encapsula também qualquer lógica adicional ao contratar um funcionário (no nosso caso apenas insere, mas poderia verificar unicidade de NIF, etc.).
* **`sp_InserirFuncionarioLogin`** – Cria os dados de login para um funcionário recém-criado, inserindo na tabela *Funcionario\_Login* o `id_funcionario` (de um funcionário existente), nome de utilizador e a *hash* da senha. Garante que cada funcionário tenha no máximo um registro de login (id é PK e FK para Funcionario).
* **`sp_RegistrarHorasTrabalhadas`** – Regista as horas trabalhadas por um funcionário num determinado mês. Recebe `@id_funcionario`, o mês e ano, horas normais e horas extra. Internamente, insere um registro (ou atualiza, caso já exista) na tabela *Horas\_Trabalhadas*. Essa procedure automatiza o processamento mensal de salários: ao chamar esta SP para cada funcionário no final do mês, os dados necessários para cálculo de vencimento são atualizados. Se o registro já existir (funcionário já tinha horas naquele mês), poderíamos optar por uma lógica de UPDATE; no nosso caso, usamos INSERT e, se fosse executada mais de uma vez para o mesmo funcionário/mês, violaria a PK composta – assumimos que é chamada uma vez por mês corretamente.

**c) Procedures de Gestão de Clientes e Mesas:**

* **`sp_InserirCliente`** – Insere um novo cliente na tabela *Cliente*, recebendo campos como nome, NIF, morada, localidade, código postal e tipo de cliente (por ex., Regular ou Ocasional). Facilita cadastrar clientes frequentes ou empresas para faturação.
* **`sp_InserirMesa`** – Adiciona uma nova mesa ao sistema (tabela *Mesa*), informando número identificador da mesa e quantidade de lugares. Inicializa por padrão como disponível. Útil caso o restaurante adquira novas mesas ou reconfigure layout.

**d) Procedures de Gestão de Pedidos (Operações de Pedido e Fatura):** englobam o fluxo desde a criação do pedido até sua finalização:

* **`sp_RealizarPedido`** – Inicia um novo pedido de mesa. Recebe como parâmetros a mesa (`@id_mesa`), o funcionário responsável (`@id_funcionario`), o cliente (`@id_cliente`) e eventuais observações do pedido. Ao executar, insere um novo registro em *Pedido* com estado inicial (por exemplo “Em andamento”) e registra data/hora atual. Retorna o `id_pedido` gerado para referência. Importante notar que esta SP apenas cria o pedido “cabeçalho”; os itens (pratos/bebidas) do pedido serão adicionados em seguida por outra procedure. O objetivo é facilitar a abertura de um pedido quando clientes se sentam – podendo ainda não definir todos itens de imediato.
* **`sp_AdicionarPratoPedido`** – Adiciona um item do tipo prato a um pedido existente. Parâmetros: `@id_pedido`, `@id_prato` e quantidade. Insere um registro em *Pedido\_Prato*. Caso o prato já exista no pedido, poder-se-ia optar por somar quantidades; contudo, a nossa implementação insere linhas separadas (podendo distinguir pedidos repetidos do mesmo prato, se necessário). Esta SP encapsula a lógica de atualizar os itens do pedido e, ao mesmo tempo, desencadeia automaticamente via triggers a atualização do stock (ao inserir em *Pedido\_Prato*, o trigger `trg_AtualizarStock_Produtos` é chamado – ver seção de triggers). Existe também de forma análoga uma procedure para adicionar bebida (`sp_AdicionarBebidaPedido`, se implementada – no nosso projeto focámos em `AdicionarPrato` por simetria, mas bebidas poderiam ser tratadas ou pelo mesmo SP se generificado).
* **`sp_FinalizarMesaEGerarFatura`** – Finaliza o atendimento de uma mesa, fechando o pedido e gerando automaticamente a fatura correspondente. Recebe `@id_mesa` como parâmetro. Internamente, esta procedure verifica se há um pedido em aberto para a mesa indicada; se houver, calcula o total do pedido somando os itens consumidos (pratos e bebidas) e aplicando as taxas de IVA apropriadas (13% nos itens de comida e 23% nas bebidas, conforme legislação). Em seguida, insere um registro em *Fatura* com o `id_pedido` atendido, data atual, total bruto e valores de IVA calculados. Após gerar a fatura, a SP também atualiza o estado do pedido para “Finalizado/Pago” e marca a mesa como disponível novamente (caso tenhamos um campo de disponibilidade em *Mesa*, poderíamos atualizar). Essencialmente, esta procedure encapsula toda a lógica de *fechamento de conta*: cálculo financeiro e persistência. Ao chamá-la, obtém-se a fatura emitida pronta para eventualmente ser mostrada/impressa. *(Nota: Dentro desta SP poderíamos também chamar a function `fn_DetalhesFatura` para compor os detalhes, mas optou-se por lógica direta e uso da function separadamente quando necessário.)*
* **`sp_InserirPedidoCompleto`** – Como alternativa ao fluxo manual de *RealizarPedido + Adicionar itens + Finalizar*, implementámos esta SP para inserção de um pedido completo de forma simplificada. Recebe parâmetros similares (mesa, funcionário, cliente, observações) e adicionalmente uma coleção de itens (lista de pratos e quantidades) – implementada através de um parâmetro do tipo tabela (*table-valued parameter* definido no SQL Server). Ao executar, esta procedure insere o pedido (como *sp\_RealizarPedido* faria) e em seguida insere todos os itens fornecidos nas tabelas *Pedido\_Prato* e *Pedido\_Bebida* correspondentes, tudo dentro de uma transação. Por fim, pode opcionalmente já chamar a finalização e gerar fatura. No fundo, *sp\_InserirPedidoCompleto* serve para cenários em que se deseja registar de uma só vez um pedido inteiro (talvez importado de um sistema externo ou inserido via um formulário consolidado). No nosso projeto, esta SP foi utilizada especialmente para **inserir dados de teste** rapidamente – por exemplo, o script de *seeds* usa `sp_InserirPedidoCompleto` para cadastrar pedidos de exemplo completos com seus itens, facilitando a carga de dados.

**e) Procedures de Gestão de Eventos Especiais:** relacionadas ao módulo de eventos e menus promocionais:

* **`sp_CriarEventoEspecial`** – Insere um novo evento especial na tabela *Evento\_Especial*, recebendo nome, descrição e datas de início/fim do evento. Essa SP facilita anunciar um novo evento promocional no sistema.
* **`sp_CriarMenuEspecial`** – Cria um novo menu especial para um determinado evento. Parâmetros incluem o nome do menu, preço fixo por pessoa e o `id_evento` ao qual o menu pertence. Insere na tabela *Menu\_Especial* e retorna o `id_menu` gerado. Normalmente utilizada logo após criar um evento, para definir os menus desse evento.
* **`sp_AdicionarPratoMenuEspecial`** – Associa um prato existente a um menu especial específico, inserindo um registro em *Menu\_Especial\_Prato*. Recebe `@id_menu` e `@id_prato` como argumentos. Com esta procedure, o gestor pode compor o menu especial escolhendo quais pratos (entrada, prato principal, sobremesa, etc.) estarão incluídos naquela oferta especial.

**f) Procedures de Relatórios Financeiros:** essas SPs fazem uso das functions desenvolvidas (ver seção 6) para apresentar resultados consolidados de interesse do gestor:

* **`sp_MostrarValorGastoVencimentos`** – Calcula e exibe o **total gasto em vencimentos** de funcionários em um determinado mês e ano. Parâmetros: `@mes` e `@ano`. Internamente, esta SP chama a função escalar `fn_ValorGastoVencimentos(@mes, @ano)` que retorna o valor calculado (soma dos vencimentos de todos funcionários naquele mês, considerando horas extra). Em seguida, a SP pode fazer um SELECT ou PRINT desse valor ou retornar ao chamador. O objetivo é fornecer uma forma rápida de obter esse indicador via procedimento armazenado, possivelmente para ser consumido por uma aplicação ou relatório externo.
* **`sp_MostrarValoresGastosStocks`** – Semelhante à anterior, esta SP utiliza a função `fn_ValoresGastosStocks(@mes, @ano)` para obter o **detalhe de custos de stock utilizados** em um determinado mês/ano. A diferença é que a function `fn_ValoresGastosStocks` é *table-valued* (retorna uma tabela listando cada produto e o montante gasto naquele produto no mês). A SP então provavelmente agrega ou itera sobre este resultado para calcular um total ou para apresentar cada linha. Na nossa implementação, *sp\_MostrarValoresGastosStocks* pode simplesmente executar um `SELECT * FROM fn_ValoresGastosStocks(mes, ano)` para listar, por produto, quanto foi gasto em ingredientes naquele período, e/ou sumarizar um total geral. Dessa forma, cumpre o requisito de apresentar os dados pretendidos usando a lógica encapsulada nas functions.

**g) Outras Procedures Utilitárias:**

* **`sp_ReporEstoqueManual`** – Esta stored procedure realiza a **reposição manual de stock** de um determinado produto. Embora o sistema possua um trigger automático para repor estoque quando atinge o mínimo (ver *trg\_ReporEstoque* na seção 7), optou-se por criar também uma SP que o gestor pode chamar para simular/encomendar reposição de um produto a qualquer momento. Por exemplo, recebimento de nova mercadoria no armazém. Parâmetros: `@id_produto` e possivelmente a quantidade a repor ou encomendar (na implementação, poderíamos decidir repor sempre a quantidade padrão de encomenda). A SP então efetua um UPDATE em *Produto*, aumentando o `stock_atual` conforme a quantidade recebida e atualizando `data_ultima_encomenda` para a data atual. Isso vai, inclusive, acionar o trigger de reposição caso se use a mesma lógica (embora neste caso específico, como é manual, o trigger de *after update* poderia não ser desejado – mas no nosso design o trigger *trg\_ReporEstoque* foca em quando o stock cai abaixo do mínimo, então a SP manual apenas incrementa stock sem cair em condição de disparar trigger de novo pedido). Em suma, *sp\_ReporEstoqueManual* permite ajustar estoques de forma controlada, por intervenção do utilizador, por exemplo após inventário ou recebimento de produtos fora do fluxo automático de vendas.

Toda essa coleção de stored procedures encontra-se nos ficheiros *05\_...sql*, *06\_...sql*, *07\_Stored\_Procedures.sql* e nos scripts de *use\_cases* (como *Funcionários.sql*, *Pedidos.sql*, *Especiais.sql*, etc.). Juntas, elas cobrem a maior parte das operações de *CRUD* e processos do sistema, desde cadastro até geração de relatórios. As SPs foram escritas de modo a garantir **atomicidade** e **consistência** nas operações (muitas envolvem múltiplas tabelas – por exemplo, *sp\_InserirPedidoCompleto* envolve inserir em *Pedido* e itens; nesses casos, utilizamos transações implícitas do SQL Server ou garantimos a ordem correta das operações para manter a integridade). Além disso, ao usar SPs, ganha-se em segurança (pode-se conceder permissões apenas de execução das SPs ao invés de acesso direto às tabelas) e em encapsulamento de lógica de negócio no lado do banco, diminuindo possibilidades de erros por parte de utilizadores/clientes da BD.

## 6. Functions desenvolvidas

Foram implementadas tanto **functions escalares** quanto **functions table-valued** para realizar cálculos frequentes e retornar conjuntos de dados derivados, respectivamente, promovendo a reutilização de lógica e a organização do código SQL.

* **`fn_ValorGastoVencimentos(@mes INT, @ano INT)` – Função Escalar:** calcula o valor total gasto em salários de funcionários no mês (`@mes`) e ano (`@ano`) fornecidos. Esta função percorre os registos de horas trabalhadas (`Horas_Trabalhadas`) filtrando pelo mês/ano indicados, realiza o cálculo de vencimento para cada funcionário e soma o total. O cálculo considera: horas normais multiplicadas pelo valor hora do funcionário, horas extra pagas de forma diferenciada conforme a quantidade (primeiras 2h extra a 1.0x, próximas 5h a 1.5x, restantes a 2.0x, conforme regra do enunciado). Implementacionalmente, dentro da função definimos uma variável acumuladora `@valor_total` do tipo DECIMAL. Em seguida, somamos para cada funcionário:

  $$
  \text{valor\_hora} \times \text{horas\_normais} + \text{valor\_hora} \times 1.5 \times \text{horas\_extra(entre 3ª e 7ª)} + \text{valor\_hora} \times 2 \times \text{horas\_extra(acima da 7ª)} 
  $$

  Isso foi realizado com auxílio de expressões CASE e SUM dentro de um SELECT. Por fim, a função retorna `@valor_total`. Sendo escalar, ela devolve um único número (DECIMAL(10,2)) correspondente ao gasto total em vencimentos naquele mês. Essa function foi utilizada pelas stored procedure e consultas para facilmente obter o dado de salários, sem repetir a lógica de cálculo em vários locais.

* **`fn_ValoresGastosStocks(@mes INT, @ano INT)` – Função Table-Valued (Inline):** calcula os **custos de stocks de produtos utilizados** num dado mês/ano, retornando um conjunto de linhas detalhando o gasto por produto. Diferente da anterior, esta function retorna uma tabela com colunas como `id_produto`, `nome_produto` e `valor_gasto` (custo dos ingredientes daquele produto usados no período). Internamente, a função realiza um SELECT que junta os dados de pedidos e produtos: essencialmente agrega a quantidade de cada produto utilizado em todos os pedidos do mês e multiplica pelo preço de custo de cada produto. Para isso, envolve junção entre *Pedido\_Prato*/*Prato\_Produto*/*Produto* (e *Pedido\_Bebida*/*Bebida\_Produto* se considerarmos bebidas) filtrando pela data do pedido dentro do mês/ano. A função então calcula, para cada produto, o somatório `SUM(pp.quantidade_utilizada * pr.preco_custo * i.quantidade)` – ou seja, quantidade de ingrediente em cada prato vezes quantidade de pratos pedidos, vezes preço de custo – obtendo o custo total daquele ingrediente consumido no mês. O resultado é retornado como uma tabela listando cada produto e seu custo total no período. Essa função permite, por exemplo, gerar um relatório detalhado de quais ingredientes estão a gerar mais despesa. Por ser *inline table-valued*, sua definição é concisa (um único SELECT com RETURN) e o otimizador do SQL Server pode incorporá-la em planos de execução com eficiência. Foi utilizada dentro da SP `sp_MostrarValoresGastosStocks` e poderia ser usada em qualquer query que precise analisar gastos por produto num período.

* **`fn_DetalhesFatura(@id_fatura INT)` – Função Table-Valued (Inline):** retorna uma tabela com todos os **detalhes de uma determinada fatura** (identificada por `@id_fatura`). O objetivo desta função é facilitar a extração das informações completas da fatura para exibição ou impressão. A função realiza um SELECT que combina dados de várias tabelas relacionadas: *Fatura*, *Pedido*, *Cliente* e os itens do pedido (pratos e bebidas). O resultado inclui, numa única tabela, campos como: dados do cliente (nome, NIF, morada – obtidos juntando *Cliente* via *Pedido.id\_cliente*), lista de itens consumidos (nome do prato/bebida, quantidade, preço unitário, subtotal por item) e totais da fatura. Em nosso caso, estruturamos a função para retornar múltiplas linhas – uma por item da fatura – incluindo colunas adicionais para dados do cliente e talvez dados do pedido, repetidos em cada linha (alternativamente poder-se-ia retornar um conjunto normalizado separando cabeçalho/itens, mas como é para visualização, optou-se por retorno “desnormalizado” dos detalhes completos). A lógica da função envolve junções entre *Fatura* -> *Pedido* -> *Cliente*, e também *Pedido\_Prato* -> *Prato* e *Pedido\_Bebida* -> *Bebida*, unindo os conjuntos via UNION ou através de sub-selects, para listar todos os itens (pratos e bebidas) pertencentes ao pedido faturado. Por exemplo, para cada prato do pedido correspondente, retorna o nome do prato, quantidade pedida e preço; idem para bebidas. Inclui ainda colunas calculadas como `preco_linha` (preço \* quantidade de cada item) e no final, através de uso de funções de janela ou junção com a própria *Fatura*, adiciona as colunas de `valor_total`, `valor_iva`, etc., que serão iguais em todas as linhas da fatura. Essa function, portanto, facilita obter algo similar a um *relatório detalhado da fatura*. Poderia ser usada numa query ou aplicação cliente para mostrar a fatura completa.

Em resumo, as **functions desenvolvidas** permitem isolar lógicas importantes: `fn_ValorGastoVencimentos` encapsula o cálculo complexo de salários (evitando replicação de lógica de cálculo de horas extra em múltiplos locais), `fn_ValoresGastosStocks` fornece uma forma fácil de obter custos de matérias-primas por período, e `fn_DetalhesFatura` simplifica a recuperação de todos os dados de uma fatura. Todas elas estão implementadas no script *04\_Functions.sql* (as duas primeiras) e *09\_Function\_Detalhes\_Fatura.sql* (a terceira), e foram escritas de modo a serem determinísticas dentro do possível e a ter boa performance (uso de índices nas junções subjacentes, etc.). Ao utilizar essas funções nas procedures e views, conseguimos um design modular e de fácil manutenção – se a regra de negócio mudar (por exemplo, porcentagens de IVA ou cálculo de horas extra), basta alterar a função relevante, refletindo automaticamente em todas SPs/views que a utilizam.

## 7. Triggers para automatização

A base de dados *Boteco\_PRO* tira partido de **triggers** (gatilhos) para automatizar certas atualizações e manter dados derivados consistentes, conforme sugerido no enunciado. Desenvolvemos três triggers principais, descritos a seguir:

* **Trigger `trg_AtualizarStock_Produtos`:** É um trigger do tipo *AFTER INSERT* definido na tabela *Pedido\_Prato* (itens de prato nos pedidos). Sua finalidade é **abater automaticamente do stock** as quantidades de produtos utilizados sempre que um novo item de pedido é inserido. Em outras palavras, quando um prato é pedido, os ingredientes necessários para confeccioná-lo devem ser decrementados do inventário de produtos. O trigger, ao disparar após a inserção em *Pedido\_Prato*, realiza um UPDATE na tabela *Produto* para cada produto envolvido, subtraindo do campo `stock_atual` a quantidade utilizada naquele pedido. Para determinar a quantidade a subtrair, o trigger une a tabela *Produto* com os registros recém-inseridos (`inserted`) e com a tabela *Prato\_Produto* para calcular `qtd_utilizada = SUM(pp.quantidade_utilizada * i.quantidade)` para cada produto (onde *pp* é alias de *Prato\_Produto* e *i* representa o conjunto inserido em *Pedido\_Prato*). Assim, considera quantos pratos foram pedidos e quanto de cada ingrediente cada prato consome, resultando na diminuição correta. Em SQL simplificado:

  ```sql
  UPDATE p
  SET p.stock_atual = p.stock_atual - usado.qtd_utilizada
  FROM Produto p
  JOIN (
      SELECT pp.id_produto, SUM(pp.quantidade_utilizada * i.quantidade) as qtd_utilizada
      FROM inserted i
      JOIN Prato_Produto pp ON pp.id_prato = i.id_prato
      GROUP BY pp.id_produto
  ) usado ON p.id_produto = usado.id_produto;
  ```

  Este trigger garante que, sempre que um pedido for registrado, o inventário de ingredientes seja imediatamente atualizado, **automatizando o processo de baixa de stock** que de outra forma teria de ser manual. Isso atende ao requisito de “sempre que é utilizado um produto este deve ser abatido do stock existente”. Importante: O trigger cobre atualmente os ingredientes de pratos; no caso de bebidas que também consomem produtos (ex: ingredientes de cocktails), seria desejável um mecanismo similar em *Pedido\_Bebida*. No nosso projeto, consideramos principalmente pratos para abater ingredientes, mas poderíamos expandir o mesmo trigger (ou criar outro) para *Pedido\_Bebida*.

* **Trigger `trg_ReporEstoque`:** Trata-se de um trigger *AFTER UPDATE* definido na tabela *Produto*. Sua função é **automatizar a reposição de stock mínimo** de produtos sempre que o stock atual cair abaixo do nível mínimo definido. A lógica implementada é a seguinte: após qualquer atualização em *Produto*, o trigger verifica os produtos cujos `stock_atual` ficaram menores que `stock_minimo`. Para esses, executa um novo UPDATE no próprio *Produto* ajustando o stock de volta ao nível desejado e registrando a data da reposição. Especificamente, usamos a fórmula:

  ```sql
  SET p.stock_atual = p.stock_atual + (p.quantidade_encomenda - p.stock_atual + p.stock_minimo),
      p.data_ultima_encomenda = GETDATE()
  ```

  aplicada a todos os produtos *p* cujo `p.stock_atual < p.stock_minimo`. Analisando a expressão: `(p.quantidade_encomenda - p.stock_atual + p.stock_minimo)` resulta na quantidade necessária para elevar o stock atual até o valor `stock_minimo` mais a *quantidade de encomenda* padrão. Em outras palavras, se o stock mínimo é 10 e a quantidade de encomenda padrão é 50, e o stock atual caiu para, digamos, 8, então a expressão calcula: 50 - 8 + 10 = 52, logo o novo stock\_atual será 8 + 52 = 60 (que é *stock\_minimo + quantidade\_encomenda*). Isso significa que, sempre que o stock passa abaixo do mínimo, consideramos que foi feita uma encomenda do produto na quantidade necessária para repor acima do mínimo. O campo `data_ultima_encomenda` é atualizado para a data atual, registrando quando ocorreu a reposição. Em termos práticos, esse trigger simula um **pedido automático ao fornecedor** quando o stock fica baixo, conforme sugerido no enunciado (automatizar encomenda ao atingir nível mínimo). Combinado com *trg\_AtualizarStock\_Produtos*, isso fecha o ciclo: o stock diminui ao usar ingredientes, e assim que cai abaixo do mínimo, é reposto automaticamente. Este mecanismo assegura que *stock\_atual* nunca fique muito abaixo do mínimo por muito tempo – imediatamente ao cair, volta a ser incrementado – evitando faltas prolongadas de ingredientes.

* **Trigger `trg_AtualizarMV_Stocks`:** É um trigger *AFTER INSERT* em *Pedido\_Prato* (similar ao *AtualizarStock\_Produtos*, podendo até ser combinado, mas implementamos separado por clareza). Sua finalidade é **manter atualizada a view materializada** de stocks utilizados, ou seja, a tabela *mv\_StocksUtilizadosPorPeriodo*. Toda vez que novos itens de pedido são inseridos, este trigger insere registros correspondentes na tabela materializada indicando quanto de cada produto foi consumido e em que data. A lógica é: para cada linha inserida em *Pedido\_Prato*, calcular a quantidade de cada produto nela (parecido com o primeiro trigger) e fazer `INSERT INTO mv_StocksUtilizadosPorPeriodo(id_produto, nome_produto, data, quantidade_utilizada)` selecionando `id_produto`, `produto.nome`, `pedido.data_hora` (convertido a data) e `quantidade_utilizada` calculada. Internamente, junta *inserted* -> *Prato\_Produto* -> *Produto* -> *Pedido* (via *Pedido.id\_pedido* presente em inserted) para obter todos esses dados. Dessa forma, se por exemplo num pedido do dia 2025-05-10 foram utilizados 5kg de Batata e 2kg de Bacalhau, o trigger irá acrescentar na tabela materializada duas linhas com data 2025-05-10, produto "Batata" 5 (kg), produto "Bacalhau" 2 (kg). Se já existissem linhas para o mesmo produto e data, poderíamos somar quantidades em vez de inserir novas linhas – mas optámos por inserir linhas separadas por simplicidade, assumindo que a tabela pode depois ser agregada via consultas. Esse trigger garante que a *mv\_StocksUtilizadosPorPeriodo* esteja sempre **sincronizada** com os dados reais de pedidos, permitindo que consultas à view materializada retornem resultados consistentes imediatamente após cada pedido. Em conjunto com o índice em `nome_produto`, isso satisfaz plenamente o requisito da materialized view de stocks utilizados por período.

Em conjunto, esses três triggers implementam os **automatismos chave** da base de dados: atualização de stock, reposição de stock e atualização de dados materializados. Todos são do tipo *AFTER* (pós-inserção ou pós-atualização) garantindo que a operação principal ocorra e só então o gatilho roda (mantendo integridade – por exemplo, o trigger de stock só roda após o item do pedido existir com sucesso). Além disso, usamos `SET NOCOUNT ON` e cuidamos para escrever os triggers de forma eficiente (agrupando operações via SQL set-based ao invés de row-by-row).

Como ilustração, segue um excerto do código do trigger `trg_AtualizarStock_Produtos`, onde se pode observar a lógica de atualização do stock com base nos registros inseridos em *Pedido\_Prato*:

```sql
CREATE TRIGGER trg_AtualizarStock_Produtos
ON Pedido_Prato
AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE Produto
    SET stock_atual = stock_atual - usado.qtd_utilizada
    FROM Produto p
    JOIN (
        SELECT 
            pp.id_produto,
            SUM(pp.quantidade_utilizada * i.quantidade) AS qtd_utilizada
        FROM inserted i
        JOIN Prato_Produto pp 
            ON pp.id_prato = i.id_prato
        GROUP BY pp.id_produto
    ) usado
        ON p.id_produto = usado.id_produto;
END;
```

*(Código do trigger de abatimento de stock: subtrai do stock dos produtos a quantidade utilizada sempre que um prato é inserido em um pedido.)*

Graças a esses triggers, a base de dados *Boteco\_PRO* possui **comportamento reativo automático**: os utilizadores não precisam se preocupar em atualizar manualmente o stock a cada venda, nem em verificar constantemente se é preciso encomendar mais produtos – o sistema faz isso sozinho conforme as regras definidas. Isso reduz erros operacionais e assegura que os dados derivados (como a tabela de consumo de stock por período) estejam sempre corretos e atualizados em tempo real, cumprindo integralmente os objetivos de automatização propostos.

## 8. Conclusão

A solução de base de dados desenvolvida para o projeto *Boteco\_PRO* atinge os objetivos propostos de forma robusta e eficiente. O esquema relacional concebido cobre todos os aspectos essenciais da gestão de um restaurante, desde o menu (categorias, pratos, bebidas e ingredientes) e estoque de produtos, até o registo de pedidos, faturação e acompanhamento de clientes e funcionários. A estrutura encontra-se normalizada e com integridade referencial garantida, evitando redundâncias e inconsistências – por exemplo, através das chaves estrangeiras, asseguramos que não haja pedidos sem cliente, itens sem pedido associado, etc., o que reforça a confiabilidade dos dados armazenados.

Ao implementar **queries, views, stored procedures, functions e triggers**, conseguimos não só satisfazer cada requisito específico do enunciado, mas também agregar funcionalidades extras que tornam o sistema mais completo. As **views analíticas** permitem ao gestor obter rapidamente indicadores financeiros (gastos e receitas por período) – uma tarefa que, sem as views, exigiria consultas SQL complexas toda vez. A opção por uma **view materializada** para consumo de stock reflete a preocupação com desempenho em análises de grandes volumes de dados históricos, enquanto os **índices** criados (por exemplo, no nome do produto na view materializada) ajudam a acelerar buscas frequentes.

As diversas **stored procedures** implementadas encapsulam as operações do dia a dia: inserir entidades base (como novos produtos, clientes, funcionários), registar pedidos e finalizar contas com emissão de fatura, criar eventos e menus promocionais, entre outras. Isso não só facilita a integração com aplicações front-end (já que expõe “métodos” prontos a serem chamados, em vez de exigir construção de SQL dinâmico), mas também diminui a margem de erro – a lógica centralizada no banco garante que, por exemplo, finalizar um pedido execute sempre todos os passos (não se esqueça de gerar a fatura ou liberar a mesa). As **functions** por sua vez eliminaram duplicação de lógica (p.e. cálculo de salários, cálculo de custos de stock), tornando o código mais organizado e fácil de manter.

Destaca-se o uso de **triggers** como ponto alto da automatização: graças a eles, a base de dados reage automaticamente a eventos. Ao inserir um item num pedido, imediatamente o stock é decrementado e registrado na tabela de consumos; ao atingir stock mínimo, automaticamente é simulado um reabastecimento. Estas automações garantem que a informação de stock esteja sempre atualizada e que o gestor tenha uma visão em tempo real da situação, cumprindo o cenário descrito no enunciado (abatimento de 5 batatas de um stock de 500 resultando instantaneamente em 495, etc.). Em conjunto, esses mecanismos automáticos reduzem a necessidade de intervenção manual em tarefas repetitivas e críticas, diminuindo erros (como esquecer de dar baixa no inventário) e aumentando a confiabilidade dos dados.

Em termos de desempenho e escalabilidade, a base de dados foi construída seguindo boas práticas do SQL Server: chaves primárias com índices clustering, chaves estrangeiras para junções eficientes, índices adicionais (como na view materializada) onde identificado necessário, e código T-SQL set-based (evitando cursores ou loops desnecessários). Testes realizados com os **scripts de povoamento de dados de exemplo** (seeds) e **consultas de caso de uso** confirmaram que o sistema responde corretamente e em tempo hábil às operações típicas. Por exemplo, conseguimos inserir vários pedidos e, em seguida, gerar relatórios do mês, observando que todos os gatilhos e cálculos foram acionados conforme esperado e os resultados batiam com os valores inseridos.

Concluindo, a solução implementada resolve o problema proposto de forma completa: **gerir um restaurante** do ponto de vista de base de dados, mantendo informação consistente sobre menu e ingredientes, controlando stock de forma automática, registrando pedidos e faturando clientes com os devidos impostos, calculando salários de funcionários e oferecendo visões consolidadas para apoio à gestão. Toda a lógica de negócio fundamental foi colocada ao nível da base de dados (views, SPs, triggers), o que contribui para centralizar as regras e facilitar futuras adaptações (por exemplo, se amanhã a taxa de IVA mudar, ou quiser adicionar um novo tipo de evento especial, basta alterar a lógica no SQL). Em suma, o *Boteco\_PRO* alcança os objetivos delineados, provendo uma base sólida para a camada de aplicação e garantindo que as operações do restaurante possam ser conduzidas com eficiência e segurança dos dados.

## 9. Referências

* **Código SQL do Projeto Boteco\_PRO:** Ficheiros `.sql` na pasta *backend/src/db* contendo a implementação do esquema e componentes discutidos (nomeadamente: *01\_Criação\_DB.sql*, *02\_Base\_Views.sql*, *03\_Materialized\_Views.sql*, *04\_Functions.sql*, *05\_SP\_Finalizar\_Mesa.sql*, *06\_SP\_Realizar\_Pedido.sql*, *07\_Stored\_Procedures.sql*, *08\_Triggers.sql*, *09\_Function\_Detalhes\_Fatura.sql*, entre outros).
* **Enunciado do Trabalho Prático BDII:** *Trabalho Prático da UC de Base de Dados II* – Universidade (2025). Documento fornecido pela docente com a descrição do cenário do restaurante e requisitos (queries, views, functions, triggers a desenvolver).
* **Documentação Microsoft SQL Server:** *Transact-SQL Reference*. Inclui detalhes sobre criação de bases de dados e objetos: CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE FUNCTION, CREATE TRIGGER, etc. Disponível em: Microsoft Docs (consultado para confirmar sintaxes e comportamentos).
